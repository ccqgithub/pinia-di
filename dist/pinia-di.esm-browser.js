import{defineComponent as t,inject as o,provide as e,onUnmounted as r,getCurrentInstance as n}from"vue";const s=Symbol("Injector Key"),i=Symbol("Instance Injector Key");class c{constructor(t,o){this.parent=null,this.records=new Map;const{parent:e=null}=o;this.parent=e,t.forEach((t=>{let o=null;if("object"==typeof t)o=Object.assign({},t);else if("function"==typeof t){o={creator:t}}if(!o)throw new Error(`Error provider onfig [${t.toString()}]!`);this.records.set(o.creator,o)}))}get(t,o){const e=this.records.get(t);let r=null;if(e?(void 0===e.use&&this._initRecord(e),r=e.use||null):this.parent&&(r=this.parent.get(t,o)),!r&&!(null==o?void 0:o.optional))throw new Error("Store not be provided, and not optional!");return r}_initRecord(t){const o={getStore:(t,o)=>this.get(t,o),onUnmounted:o=>{t.dispose=o}};t.use=t.creator(o)}dispose(){var t;const{records:o}=this,e=o.keys();for(const r of e){const e=null===(t=o.get(r))||void 0===t?void 0:t.dispose;e&&e()}}}class l{constructor(t,o){this.parent=null,this.records=new Map;const{parent:e=null}=o;this.parent=e,t.forEach((t=>{let o=null;if("object"==typeof t)o=Object.assign({},t);else if("function"==typeof t){o={creator:t}}if(!o)throw new Error(`Error provider onfig [${t.toString()}]!`);this.records.set(o.creator,o)}))}get(t,o){const e=this.records.get(t);let r=null;if(e?(void 0===e.use&&this._initRecord(e),r=e.use||null):this.parent&&(r=this.parent.get(t,o)),!r&&!(null==o?void 0:o.optional))throw new Error("Store not be provided, and not optional!");return r}_initRecord(t){const o={getStore:(t,o)=>this.get(t,o),onUnmounted:o=>{t.dispose=o}};t.use=t.creator(o)}dispose(){var t;const{records:o}=this,e=o.keys();for(const r of e){const e=null===(t=o.get(r))||void 0===t?void 0:t.dispose;e&&e()}}}const p=t({props:{stores:{type:Object,required:!0}},setup(t){const n=o(s),i=new l(t.stores,{parent:n||null});e(s,i),r((()=>{i.dispose()}))}}),d=t=>{const l=n(),p=o(s,null),d=new c(t.stores,{parent:p});l[i]=d,e(s,d),r((()=>{d.dispose()}))},a=(t,e)=>{const r=n()[i]||o(s,null);if(!r){if(!e||!e.optional)throw new Error("Never register any injectorÃ¥!");return null}return r.get(t,e)},u={},h=t=>(u[t]||(u[t]=0),u[t]++,`${t}~${u[t]}}`);export{c as Injector,p as StoreProvider,s as injectorKey,i as instanceInjectorKey,d as provideStores,a as useStore,h as useStoreId};
