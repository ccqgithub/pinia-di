import{defineComponent as t,inject as e,provide as o,onUnmounted as r,getCurrentInstance as n}from"vue";const s=Symbol("Injector Key"),i=Symbol("Instance Injector Key");let c=0;class a{constructor(t,e){this.id="",this.name="",this.parent=null,this.records=new Map;const{parent:o=null,name:r=""}=e;this.id=""+c++,this.name=r,this.parent=o,t.forEach((t=>{let e=null;if("object"==typeof t)e=Object.assign({},t);else if("function"==typeof t){e={creator:t}}if(!e)throw new Error(`Error provider onfig [${t.toString()}]!`);this.records.set(e.creator,e)}))}get(t,e){const o=this.records.get(t);let r=null;if(o?(void 0===o.use&&this._initRecord(o),r=o.use||null):this.parent&&(r=this.parent.get(t,e)),!r&&!(null==e?void 0:e.optional))throw new Error("Store not be provided, and not optional!");return r}_initRecord(t){const e={getStore:(t,e)=>this.get(t,e),onUnmounted:e=>{t.dispose=e},useStoreId:t=>this.name?`${t}~[${this.name}]~<${this.id}>`:`${t}~<${this.id}>`};t.use=t.creator(e)}dispose(){var t;const{records:e}=this,o=e.keys();for(const r of o){const o=null===(t=e.get(r))||void 0===t?void 0:t.dispose;o&&o()}}}let l=0;class d{constructor(t,e){this.id="",this.name="",this.parent=null,this.records=new Map;const{parent:o=null,name:r=""}=e;this.id=""+l++,this.name=r,this.parent=o,t.forEach((t=>{let e=null;if("object"==typeof t)e=Object.assign({},t);else if("function"==typeof t){e={creator:t}}if(!e)throw new Error(`Error provider onfig [${t.toString()}]!`);this.records.set(e.creator,e)}))}get(t,e){const o=this.records.get(t);let r=null;if(o?(void 0===o.use&&this._initRecord(o),r=o.use||null):this.parent&&(r=this.parent.get(t,e)),!r&&!(null==e?void 0:e.optional))throw new Error("Store not be provided, and not optional!");return r}_initRecord(t){const e={getStore:(t,e)=>this.get(t,e),onUnmounted:e=>{t.dispose=e},useStoreId:t=>this.name?`${t}~[${this.name}]~<${this.id}>`:`${t}~<${this.id}>`};t.use=t.creator(e)}dispose(){var t;const{records:e}=this,o=e.keys();for(const r of o){const o=null===(t=e.get(r))||void 0===t?void 0:t.dispose;o&&o()}}}const h=t({props:{stores:{type:Object,required:!0},name:{type:String,requred:!1}},setup(t){const n=e(s),i=new d(t.stores,{parent:n||null,name:t.name});o(s,i),r((()=>{i.dispose()}))}}),p=t=>{const c=n(),l=e(s,null),d=new a(t.stores,{parent:l,name:t.name});c[i]=d,o(s,d),r((()=>{d.dispose()}))},u=(t,o)=>{const r=n()[i]||e(s,null);if(!r){if(!o||!o.optional)throw new Error("Never register any injector√•!");return null}return r.get(t,o)};export{a as Injector,h as StoreProvider,s as injectorKey,i as instanceInjectorKey,p as provideStores,u as useStore};
