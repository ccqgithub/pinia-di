import{defineComponent as e,inject as t,ref as o,watch as r,provide as n,onUnmounted as s,computed as i}from"vue";const l=Symbol("Injector Key");let c=0;class a{constructor(e,t={}){this.id="",this.name="",this.providers=[],this.parent=null,this.records=new Map;const{parent:o=null,oldInjector:r=null,name:n=""}=t;this.id=""+c++,this.name=n,this.parent=o;const s=(null==r?void 0:r.providers)||[],i=[];e.forEach((e=>{const t="object"==typeof e?e.creator:e,o=s.find((e=>e===t||e.creator===t));if(o){const t="object"==typeof o?o:{creator:o},n="object"==typeof e?e:{creator:e};if(n.creator===t.creator&&n.use===t.use)return i.push(n.creator),void this.records.set(n.creator,r.records.get(n.creator))}let n=null;if("object"==typeof e)n=Object.assign({},e);else if("function"==typeof e){n={creator:e}}if(!n)throw new Error(`Error provider onfig [${e.toString()}]!`);this.records.set(n.creator,n)})),s.forEach((e=>{var t;const o="object"==typeof e?e.creator:e;if(i.includes(o))return;const n=null==r?void 0:r.records.get(o);null===(t=null==n?void 0:n.dispose)||void 0===t||t.call(n)})),this.providers=e}get(e,t){const o=this.records.get(e);let r=null;if(o?(void 0===o.use&&this._initRecord(o),r=o.use||null):this.parent&&(r=this.parent.get(e,t)),!r&&!(null==t?void 0:t.optional))throw new Error("Store not be provided, and not optional!");return r}_initRecord(e){const t={getStore:(e,t)=>this.get(e,t),onUnmounted:t=>{e.dispose=t},useStoreId:e=>this.name?`${e}~[${this.name}]~<${this.id}>`:`${e}~<${this.id}>`};e.use=e.creator(t)}dispose(){var e;const{records:t}=this,o=t.keys();for(const r of o){const o=null===(e=t.get(r))||void 0===e?void 0:e.dispose;o&&o()}}}let d=0;class u{constructor(e,t={}){this.id="",this.name="",this.providers=[],this.parent=null,this.records=new Map;const{parent:o=null,oldInjector:r=null,name:n=""}=t;this.id=""+d++,this.name=n,this.parent=o;const s=(null==r?void 0:r.providers)||[],i=[];e.forEach((e=>{const t="object"==typeof e?e.creator:e,o=s.find((e=>e===t||e.creator===t));if(o){const t="object"==typeof o?o:{creator:o},n="object"==typeof e?e:{creator:e};if(n.creator===t.creator&&n.use===t.use)return i.push(n.creator),void this.records.set(n.creator,r.records.get(n.creator))}let n=null;if("object"==typeof e)n=Object.assign({},e);else if("function"==typeof e){n={creator:e}}if(!n)throw new Error(`Error provider onfig [${e.toString()}]!`);this.records.set(n.creator,n)})),s.forEach((e=>{var t;const o="object"==typeof e?e.creator:e;if(i.includes(o))return;const n=null==r?void 0:r.records.get(o);null===(t=null==n?void 0:n.dispose)||void 0===t||t.call(n)})),this.providers=e}get(e,t){const o=this.records.get(e);let r=null;if(o?(void 0===o.use&&this._initRecord(o),r=o.use||null):this.parent&&(r=this.parent.get(e,t)),!r&&!(null==t?void 0:t.optional))throw new Error("Store not be provided, and not optional!");return r}_initRecord(e){const t={getStore:(e,t)=>this.get(e,t),onUnmounted:t=>{e.dispose=t},useStoreId:e=>this.name?`${e}~[${this.name}]~<${this.id}>`:`${e}~<${this.id}>`};e.use=e.creator(t)}dispose(){var e;const{records:t}=this,o=t.keys();for(const r of o){const o=null===(e=t.get(r))||void 0===e?void 0:e.dispose;o&&o()}}}const p=e({props:{stores:{type:Object,required:!0},name:{type:String,requred:!1}},setup(e){const i=t(l,null),c=new u(e.stores,{parent:(null==i?void 0:i.value)||null,oldInjector:null,name:e.name}),a=o(c);let d=c;const p=r((()=>({parent:(null==i?void 0:i.value)||null,stores:e.stores})),(({parent:t,stores:o})=>{a.value=new u(o,{parent:t,oldInjector:d,name:e.name}),d=a.value}));n(l,a),s((()=>{p(),a.value.dispose()}))}}),h=e=>{const i=t(l,null),c=new a(e.stores,{parent:(null==i?void 0:i.value)||null,oldInjector:null,name:e.name}),d=o(c);let u=c;const p=r((()=>({parent:(null==i?void 0:i.value)||null,stores:e.stores})),(({parent:t,stores:o})=>{d.value=new a(o,{parent:t,oldInjector:u,name:e.name}),u=d.value}));n(l,d),s((()=>{p(),d.value.dispose()}))},v=(e,o)=>{const r=t(l,null);if(!r){if(!o||!o.optional)throw new Error(`Never register any injector for ${e.toString()}!`);return null}return i((()=>r.value.get(e,o)))},f=(e,t="")=>{const o=new a(e,{name:t});return[l,o]};export{a as Injector,p as StoreProvider,f as getProvideArgs,l as injectorKey,h as useProvideStores,v as useStore};
